  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module merak::merak_schema {

  use std::ascii::String;

  use std::ascii::string;

  use sui::package::UpgradeCap;

  use std::type_name;

  use dubhe::storage;

  use dubhe::storage_value::{Self, StorageValue};

  use dubhe::storage_map::{Self, StorageMap};

  use dubhe::storage_double_map::{Self, StorageDoubleMap};

  use sui::dynamic_field as df;

  use merak::merak_account_status::AccountStatus;

  use merak::merak_asset_status::AssetStatus;

  use merak::merak_account::Account;

  use merak::merak_asset_metadata::AssetMetadata;

  use merak::merak_pool::Pool;

  use merak::merak_path_element::PathElement;

  use merak::merak_bridge_config::BridgeConfig;

  public struct Schema has key, store {
    id: UID,
  }

  public fun borrow_next_asset_id(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"next_asset_id")
  }

  public(package) fun next_asset_id(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"next_asset_id")
  }

  public fun borrow_asset_metadata(self: &Schema): &StorageMap<u256, AssetMetadata> {
    storage::borrow_field(&self.id, b"asset_metadata")
  }

  public(package) fun asset_metadata(self: &mut Schema): &mut StorageMap<u256, AssetMetadata> {
    storage::borrow_mut_field(&mut self.id, b"asset_metadata")
  }

  public fun borrow_account(self: &Schema): &StorageDoubleMap<u256, address, Account> {
    storage::borrow_field(&self.id, b"account")
  }

  public(package) fun account(self: &mut Schema): &mut StorageDoubleMap<u256, address, Account> {
    storage::borrow_mut_field(&mut self.id, b"account")
  }

  public fun borrow_swap_fee(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"swap_fee")
  }

  public(package) fun swap_fee(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"swap_fee")
  }

  public fun borrow_lp_fee(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"lp_fee")
  }

  public(package) fun lp_fee(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"lp_fee")
  }

  public fun borrow_fee_to(self: &Schema): &StorageValue<address> {
    storage::borrow_field(&self.id, b"fee_to")
  }

  public(package) fun fee_to(self: &mut Schema): &mut StorageValue<address> {
    storage::borrow_mut_field(&mut self.id, b"fee_to")
  }

  public fun borrow_max_swap_path_len(self: &Schema): &StorageValue<u64> {
    storage::borrow_field(&self.id, b"max_swap_path_len")
  }

  public(package) fun max_swap_path_len(self: &mut Schema): &mut StorageValue<u64> {
    storage::borrow_mut_field(&mut self.id, b"max_swap_path_len")
  }

  public fun borrow_min_liquidity(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"min_liquidity")
  }

  public(package) fun min_liquidity(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"min_liquidity")
  }

  public fun borrow_pools(self: &Schema): &StorageDoubleMap<u256, u256, Pool> {
    storage::borrow_field(&self.id, b"pools")
  }

  public(package) fun pools(self: &mut Schema): &mut StorageDoubleMap<u256, u256, Pool> {
    storage::borrow_mut_field(&mut self.id, b"pools")
  }

  public fun borrow_bridge(self: &Schema): &StorageMap<String, BridgeConfig> {
    storage::borrow_field(&self.id, b"bridge")
  }

  public(package) fun bridge(self: &mut Schema): &mut StorageMap<String, BridgeConfig> {
    storage::borrow_mut_field(&mut self.id, b"bridge")
  }

  public(package) fun create(ctx: &mut TxContext): Schema {
    let mut id = object::new(ctx);
    storage::add_field<StorageValue<u256>>(&mut id, b"next_asset_id", storage_value::new(b"next_asset_id", ctx));
    storage::add_field<StorageMap<u256, AssetMetadata>>(&mut id, b"asset_metadata", storage_map::new(b"asset_metadata", ctx));
    storage::add_field<StorageDoubleMap<u256, address, Account>>(&mut id, b"account", storage_double_map::new(b"account", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"swap_fee", storage_value::new(b"swap_fee", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"lp_fee", storage_value::new(b"lp_fee", ctx));
    storage::add_field<StorageValue<address>>(&mut id, b"fee_to", storage_value::new(b"fee_to", ctx));
    storage::add_field<StorageValue<u64>>(&mut id, b"max_swap_path_len", storage_value::new(b"max_swap_path_len", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"min_liquidity", storage_value::new(b"min_liquidity", ctx));
    storage::add_field<StorageDoubleMap<u256, u256, Pool>>(&mut id, b"pools", storage_double_map::new(b"pools", ctx));
    storage::add_field<StorageMap<String, BridgeConfig>>(&mut id, b"bridge", storage_map::new(b"bridge", ctx));
    Schema { id }
  }

  public(package) fun id(self: &mut Schema): &mut UID {
    &mut self.id
  }

  public(package) fun borrow_id(self: &Schema): &UID {
    &self.id
  }

  public fun migrate(_schema: &mut Schema, _cap: &UpgradeCap, _ctx: &mut TxContext) {}

  // ======================================== View Functions ========================================

  public fun get_next_asset_id(self: &Schema): &u256 {
    self.borrow_next_asset_id().get()
  }

  public fun get_asset_metadata(self: &Schema, key: u256): &AssetMetadata {
    self.borrow_asset_metadata().get(key)
  }

  public fun get_account(self: &Schema, key1: u256, key2: address): &Account {
    self.borrow_account().get(key1, key2)
  }

  public fun get_swap_fee(self: &Schema): &u256 {
    self.borrow_swap_fee().get()
  }

  public fun get_lp_fee(self: &Schema): &u256 {
    self.borrow_lp_fee().get()
  }

  public fun get_fee_to(self: &Schema): &address {
    self.borrow_fee_to().get()
  }

  public fun get_max_swap_path_len(self: &Schema): &u64 {
    self.borrow_max_swap_path_len().get()
  }

  public fun get_min_liquidity(self: &Schema): &u256 {
    self.borrow_min_liquidity().get()
  }

  public fun get_pools(self: &Schema, key1: u256, key2: u256): &Pool {
    self.borrow_pools().get(key1, key2)
  }

  public fun get_bridge(self: &Schema, key: String): &BridgeConfig {
    self.borrow_bridge().get(key)
  }

  // =========================================================================================================
}
